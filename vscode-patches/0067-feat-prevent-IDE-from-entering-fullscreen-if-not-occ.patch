From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jean-Damien Thevenoux <jean-damien.thevenoux@codingame.com>
Date: Fri, 21 Nov 2025 18:15:16 +0100
Subject: [PATCH] feat: prevent IDE from entering fullscreen if not occupying
 the entire screen

---
 src/vs/base/browser/dom.ts                    | 32 ++++++++++++++++---
 src/vs/workbench/browser/layout.ts            |  5 +--
 src/vs/workbench/browser/web.main.ts          |  2 +-
 .../host/browser/browserHostService.ts        |  2 +-
 4 files changed, 32 insertions(+), 9 deletions(-)

diff --git a/src/vs/base/browser/dom.ts b/src/vs/base/browser/dom.ts
index adfb9f657ae..98cfab3ae62 100644
--- a/src/vs/base/browser/dom.ts
+++ b/src/vs/base/browser/dom.ts
@@ -925,6 +925,26 @@ export function getActiveElement(_document = getActiveDocument()): Element | nul
 	return result;
 }
 
+/**
+ * Returns the fullscreen element, if any, by walking through
+ * nested shadow roots.
+ * Only element-based fullscreen created via requestFullscreen() is returned.
+*/
+export function getFullscreenElement(_document = getActiveDocument()): Element | null {
+	const _getFullscreenElement = (node: Document | ShadowRoot): Element | null =>
+		node.fullscreenElement ??
+		(<any>node).webkitFullscreenElement ??
+		null
+
+	let result = _getFullscreenElement(_document);
+
+	while (result?.shadowRoot) {
+		result = _getFullscreenElement(result.shadowRoot);
+	}
+
+	return result;
+}
+
 export function getRootContainer(element: Element) {
 	let container: Node = element.getRootNode();
 	if (container instanceof Document) {
@@ -1699,11 +1719,11 @@ export interface IDetectedFullscreen {
 	guess: boolean;
 }
 
-export function detectFullscreen(targetWindow: Window): IDetectedFullscreen | null {
+export function detectFullscreen(targetWindow: Window, containerElement: Element): IDetectedFullscreen | null {
 
 	// Browser fullscreen: use DOM APIs to detect
-	// eslint-disable-next-line local/code-no-any-casts
-	if (targetWindow.document.fullscreenElement || (<any>targetWindow.document).webkitFullscreenElement || (<any>targetWindow.document).webkitIsFullScreen) {
+	const fullscreenElement = getFullscreenElement(targetWindow.document)
+	if (fullscreenElement === containerElement) {
 		return { mode: DetectedFullscreenMode.DOCUMENT, guess: false };
 	}
 
@@ -1712,7 +1732,9 @@ export function detectFullscreen(targetWindow: Window): IDetectedFullscreen | nu
 	// height and comparing that to window height, we can guess
 	// it though.
 
-	if (targetWindow.innerHeight === targetWindow.screen.height) {
+	const isContainerFullScreen = containerElement.getBoundingClientRect().height >= targetWindow.screen.height;
+
+	if (targetWindow.innerHeight === targetWindow.screen.height && isContainerFullScreen) {
 		// if the height of the window matches the screen height, we can
 		// safely assume that the browser is fullscreen because no browser
 		// chrome is taking height away (e.g. like toolbars).
@@ -1721,7 +1743,7 @@ export function detectFullscreen(targetWindow: Window): IDetectedFullscreen | nu
 
 	if (platform.isMacintosh || platform.isLinux) {
 		// macOS and Linux do not properly report `innerHeight`, only Windows does
-		if (targetWindow.outerHeight === targetWindow.screen.height && targetWindow.outerWidth === targetWindow.screen.width) {
+		if (targetWindow.outerHeight === targetWindow.screen.height && targetWindow.outerWidth === targetWindow.screen.width && isContainerFullScreen) {
 			// if the height of the browser matches the screen height, we can
 			// only guess that we are in fullscreen. It is also possible that
 			// the user has turned off taskbars in the OS and the browser is
diff --git a/src/vs/workbench/browser/layout.ts b/src/vs/workbench/browser/layout.ts
index 057bfdb82c9..99aa6df59fa 100644
--- a/src/vs/workbench/browser/layout.ts
+++ b/src/vs/workbench/browser/layout.ts
@@ -5,7 +5,7 @@
 
 import { Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from '../../base/common/lifecycle.js';
 import { Event, Emitter } from '../../base/common/event.js';
-import { EventType, addDisposableListener, getClientArea, size, IDimension, isAncestorUsingFlowTo, computeScreenAwareSize, getActiveDocument, getWindows, getActiveWindow, isActiveDocument, getWindow, getWindowId, getActiveElement, Dimension } from '../../base/browser/dom.js';
+import { EventType, addDisposableListener, getClientArea, size, IDimension, isAncestorUsingFlowTo, computeScreenAwareSize, getActiveDocument, getWindows, getActiveWindow, isActiveDocument, getWindow, getWindowId, getActiveElement, Dimension, getFullscreenElement } from '../../base/browser/dom.js';
 import { onDidChangeFullscreen, isFullscreen, isWCOEnabled } from '../../base/browser/browser.js';
 import { isWindows, isLinux, isMacintosh, isWeb, isIOS } from '../../base/common/platform.js';
 import { EditorInputCapabilities, GroupIdentifier, isResourceEditorInput, IUntypedEditorInput, pathsToEditors } from '../common/editor.js';
@@ -1633,7 +1633,8 @@ export abstract class Layout extends Disposable implements IWorkbenchLayoutServi
 
 	layout(): void {
 		if (!this.disposed) {
-			this._mainContainerDimension = getClientArea(this.state.runtime.mainWindowFullscreen ?
+			const fullscreenElement = getFullscreenElement(mainWindow.document)
+			this._mainContainerDimension = getClientArea(this.state.runtime.mainWindowFullscreen && this.mainContainer === fullscreenElement ?
 				mainWindow.document.body : 	// in fullscreen mode, make sure to use <body> element because
 				this.parent,				// in that case the workbench will span the entire site
 				this.contextService.getWorkbenchState() === WorkbenchState.EMPTY ? DEFAULT_EMPTY_WINDOW_DIMENSIONS : DEFAULT_WORKSPACE_WINDOW_DIMENSIONS // running with fallback to ensure no error is thrown (https://github.com/microsoft/vscode/issues/240242)
diff --git a/src/vs/workbench/browser/web.main.ts b/src/vs/workbench/browser/web.main.ts
index fedadefc0b3..98275b2829b 100644
--- a/src/vs/workbench/browser/web.main.ts
+++ b/src/vs/workbench/browser/web.main.ts
@@ -113,7 +113,7 @@ export class BrowserMain extends Disposable {
 	private init(): void {
 
 		// Browser config
-		setFullscreen(!!detectFullscreen(mainWindow), mainWindow);
+		setFullscreen(!!detectFullscreen(mainWindow, this.domElement), mainWindow);
 	}
 
 	async open(): Promise<IWorkbench> {
diff --git a/src/vs/workbench/services/host/browser/browserHostService.ts b/src/vs/workbench/services/host/browser/browserHostService.ts
index 43aaec01f84..81419568733 100644
--- a/src/vs/workbench/services/host/browser/browserHostService.ts
+++ b/src/vs/workbench/services/host/browser/browserHostService.ts
@@ -218,7 +218,7 @@ export class BrowserHostService extends Disposable implements IHostService {
 			const viewport = isIOS && window.visualViewport ? window.visualViewport /** Visual viewport */ : window /** Layout viewport */;
 
 			const isFullScreen = () => {
-				const fullScreen = detectFullscreen(window);
+				const fullScreen = detectFullscreen(window, this.layoutService.getContainer(window));
 				return fullScreen !== null && !fullScreen.guess;
 			};
 
